{
    "componentChunkName": "component---src-templates-prob-solving-template-js",
    "path": "/boj20292",
    "result": {"pageContext":{"html":"<h2>문제</h2>\n<p>Sogang ICPC Team에서는 학회원들을 돕기 위해 Sogang Program Consulting Team(이하 SPC Team)을 만들었다. SPC Team은 학회원들과 화목하게 지내게 될 날만을 상상하며 에러가 발생한 코드를 무료로 디버깅해주는 컨설팅을 바로 시작했다.</p>\n<p>그러던 어느 날, 기세등등했던 SPC Team의 모두를 당황시킨 코드가 등장했다. 아무리 봐도 정상적인 코드인데, 원하는 데이터를 얻을 수 없었던 것이다. 하지만 포기를 모르는 SPC Team은 계속해서 디버깅을 시도한 끝에, 한 번에 여러 줄의 명령이 실행되고 있었다는 사실을 알게 되었다! 이 상황을 이해하기 위해 다음 예시를 살펴보자.</p>\n<p><code>1: WRITE A TO B</code><br>\n<code>2: WRITE B TO C</code><br>\n<code>3: READ B</code><br>\n<code>4: READ C</code><br>\n<code>5: EXIT</code></p>\n<p>위 코드는 문제가 된 학회원의 코드이다. 명령어가 순서대로 실행되면 전혀 문제가 없을 코드지만, 줄 1–4가 동시에 실행된다면 문제가 생긴다. 메모리 A에서 메모리 B로 데이터가 옮겨지지도 않았는데 두 번째 줄이 실행되면, 메모리 C에 무슨 데이터가 들어갈지 알 수 없다. 이러한 문제를 확인한 SPC Team은 다음과 같이 컨설팅을 해 주었다.</p>\n<p><code>1: WRITE A TO B</code><br>\n<code>2: WAIT</code><br>\n<code>3: WRITE B TO C</code><br>\n<code>4: WAIT</code><br>\n<code>5: READ B</code><br>\n<code>6: READ C</code><br>\n<code>7: EXIT</code></p>\n<p>위와 같이, 중간에 <code>WAIT</code>를 삽입하여 <code>WRITE A TO B</code>와 <code>WRITE B TO C</code>가 동시에 실행되는 것을 막아준다면, 메모리 C에 어떤 데이터가 들어갈지 명확해진다! 위 코드에 대한 컨설팅을 끝마친 SPC Team은 문제가 발생할 수 있는 경우를 다음과 같이 세 가지로 분류했다.</p>\n<ul>\n<li>READ with WRITE\n<ul>\n<li><code>WRITE A TO B</code>와 <code>READ B</code>가 동시에 실행되면, 메모리 B의 데이터가 확실하지 않으므로 두 명령어 사이에 <code>WAIT</code>가 있어야 한다.</li>\n<li><code>WRITE A TO B</code>와 <code>WRITE B TO C</code>가 동시에 실행되면, 메모리 C의 데이터가 확실하지 않으므로 두 명령어 사이에 <code>WAIT</code>가 있어야 한다.</li>\n</ul>\n</li>\n<li>WRITE with WRITE\n<ul>\n<li><code>WRITE A TO C</code>와 <code>WRITE B TO C</code>가 동시에 실행되면, 메모리 C의 데이터가 확실하지 않으므로 두 명령어 사이에 <code>WAIT</code>가 있어야 한다.</li>\n<li><code>WRITE A TO B</code>와 다른 <code>WRITE A TO B</code>가 동시에 실행되는 것은 문제가 없지만, 프로그램의 안정성을 위해 두 명령어 사이에 <code>WAIT</code>가 있어야 한다.</li>\n</ul>\n</li>\n<li>교착 상태\n<ul>\n<li><code>WRITE A TO B</code>와 <code>WRITE B TO A</code>가 동시에 실행되면, 메모리 A와 메모리 B의 값이 확실하지 않으므로 두 명령어 사이에 <code>WAIT</code>가 있어야 한다.</li>\n</ul>\n</li>\n</ul>\n<p>이 문제를 겪고 있는 학회원들이 지속적으로 SPC Team에 컨설팅 문의를 신청하고 있다. 반복되는 작업에 지친 SPC Team은 위와 같은 상황을 알아서 탐지하여 컨설팅해주는 프로그램을 만들고자 한다. 하지만 너무나도 바쁜 나머지, 유능한 프로그래머인 당신에게 프로그램의 제작을 의뢰했다. 너무나도 마음이 상냥한 당신은 이 의뢰를 거절할 수 없다!</p>\n<h3>입력</h3>\n<p>입력으로 최대 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>10</mn><mo separator=\"true\">,</mo><mn>000</mn></mrow><annotation encoding=\"application/x-tex\">10,000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8389em;vertical-align:-0.1944em;\"></span><span class=\"mord\">10</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.1667em;\"></span><span class=\"mord\">000</span></span></span></span></span> 줄의 명령어가 주어지며, <code>WRITE</code>문, <code>READ</code>문, <code>EXIT</code>문으로 구성된다. <code>EXIT</code>문은 마지막에 한 번만 주어진다.</p>\n<p>각 명령어는 다음과 같이 정의되며, 메모리 이름은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span>~<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn></mrow><annotation encoding=\"application/x-tex\">3</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">3</span></span></span></span></span> 글자의 알파벳 대문자로 구성되어 있다.</p>\n<ul>\n<li><strong>WRITE A TO B:</strong> 메모리 A의 내용을 메모리 B로 옮긴다. 이 때, 메모리 A는 READ 상태가 된다.</li>\n<li><strong>READ A:</strong> 메모리 A의 데이터를 읽는다.</li>\n<li><strong>EXIT:</strong> 프로그램을 종료한다.</li>\n</ul>\n<p><code>WRITE A TO A</code> 같이 동일한 메모리로 WRITE를 수행하는 경우는 없다.</p>\n<h3>출력</h3>\n<p>WAIT을 최소로 사용한 컨설팅 결과를 기존 명령어들의 순서를 유지하여 출력한다.</p>\n<p>한 줄에 하나의 명령어만 출력해야 하며, 만약 그러한 컨설팅 결과가 여러 개라면 그 중 하나를 출력한다.</p>\n<hr />\n<h4>1. 문제를 해결하기 위해 사용한 것들</h4>\n<ul>\n<li><strong>Set</strong>과 <strong>Multimap</strong>을 이용하였다.</li>\n<li>Multimap을 이용하여 <code>WRITE A TO B</code>가 나타나면 Multimap에 A → B 와 B → A를 각각 저장해주었다.</li>\n<li>Set을 이용하여 <code>READ A</code>가 나타나면 Set에 A를 저장해주었다.</li>\n<li>각각의 조건들(READ with WRITE / WRITE with WRITE / 교착상태 등)을 확인해주기 위해 Multimap의 메소드인 <strong>count</strong>를 중요하게 활용하였다.\r\n(count: 키가 매개변수로 지정된 키와 일치하는 multimap의 요소 수를 반환함)</li>\n</ul>\n<h4>2. 입력) string 클래스의 find와 substr 활용!</h4>\n<ul>\n<li>이 문제의 입력은 <code>WRITE A TO B</code>, <code>READ A</code>와 같이 명령어와 스페이스, 메모리의 이름으로 구분되어있다.</li>\n<li>이를 <code>getline</code>으로 <strong>스페이스를 포함한 전체 명령어</strong>를 입력받는다.</li>\n<li>따라서 string 클래스의 find 메소드를 통해 <strong>스페이스들의 인덱스</strong>를 알아내고 substr 메소드를 사용하여<br>\n<strong>메모리의 이름을 쉽게 추출</strong>할 수 있다.</li>\n<li>각 명령어들은 첫글자가 'W'인지, 'R'인지, 'E'인지 구분만 해주면 된다.</li>\n</ul>\n<h4>3. 알고리즘</h4>\n<ul>\n<li>\n<p><code>WRITE</code>명령어가 들어오면 다음과 같이 처리한다.</p>\n<ul>\n<li>\n<p>우선 WAIT가 필요한 상황인지 아닌지를 검사한다. WAIT가 필요하다면 <code>WAIT</code>를 결과 벡터에 넣고, 모든 multimap과 set을 비운 후, 선언한 multimap 두 개에 알맞는 pair들을 아래와 같이 넣는다. 그리고, 결과 벡터에 해당 명령 전체를 넣는다.</p>\n</li>\n<li>\n<p>WRITE A TO B라고 했을 때, <code>multimap&#x3C;string, string> write_from_to</code>에는 정순서 (A, B)를 넣어주고, <code>multimap&#x3C;string, string> write_to_from</code>에는 역순서 (B, A)를 넣어준다.</p>\n<p>역순서를 넣는 이유는 WRITE with WRITE 의 첫 번째 조건처럼 <code>WRITE A TO C</code>가 먼저 들어오고 나중에 <code>WRITE B TO C</code>가 들어왔을 때, 이전에 C에 내용을 옮기려는 시도가 있었는지를 확인하기 위함이다. 이 경우,\r\n<code>write_to_from.count(C)</code>를 해서 나온 결과가 0이 아니라면 그러한 시도가 있었다는 것이 되고, <code>WAIT</code>를 결과 벡터에 넣어주면 되기 때문이다.</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>READ</code>명령어가 들어오면 다음과 같이 처리한다.</p>\n<ul>\n<li>우선 WAIT가 필요한 상황인지 아닌지를 검사한다. WAIT가 필요하다면 <code>WAIT</code>를 결과 벡터에 넣고, 모든 multimap과 set을 비운 후, set에 해당 메모리의 이름을 넣어준다. 또, 결과 벡터에 해당 명령 전체를 넣는다.<br>\n(READ A라고 했을 때, <code>set&#x3C;string> read</code>에 해당 메모리의 이름을 넣어준다(insert 메서드)).</li>\n</ul>\n</li>\n<li>\n<p><code>EXIT</code>명령어가 들어오면 그냥 반복문 자체를 break 해버리면 된다.</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;set&gt;\r\n#include &lt;map&gt;\r\n\r\nusing namespace std;\r\n\r\nmultimap&lt;string, string&gt; write_from_to;\r\nmultimap&lt;string, string&gt; write_to_from;\r\nmultimap&lt;string, string&gt;::iterator it;\r\nset&lt;string&gt; read;\r\nvector&lt;string&gt; result;\r\n\r\nvoid clearAll()\r\n{\r\n    write_from_to.clear();\r\n    write_to_from.clear();\r\n    read.clear();\r\n}\r\n\r\nint main()\r\n{\r\n    string command;\r\n\r\n    while (true)\r\n    {\r\n        getline(cin, command);\r\n\r\n        string a, b;\r\n        int index1, index2, index3;\r\n\r\n        if (command[0] == &#39;E&#39;)\r\n        {\r\n            result.push_back(&quot;EXIT&quot;);\r\n            break;\r\n        }\r\n\r\n        else if (command[0] == &#39;W&#39;)\r\n        {\r\n            index1 = command.find(&quot; &quot;);\r\n            index2 = command.find(&quot; &quot;, index1 + 1);\r\n            index3 = command.find(&quot; &quot;, index2 + 1);\r\n\r\n            a = command.substr(index1 + 1, index2 - index1 - 1);\r\n            b = command.substr(index3 + 1, command.length() - index3 - 1);\r\n\r\n            // Read with Write 1\r\n            if (read.count(b) != 0)\r\n            {\r\n                result.push_back(&quot;WAIT&quot;);\r\n                clearAll();\r\n            }\r\n\r\n            // Read with Write 2 + 교착상태 조건\r\n            else if (write_from_to.count(b) != 0 || write_to_from.count(a) != 0)\r\n            {\r\n                result.push_back(&quot;WAIT&quot;);\r\n                clearAll();\r\n            }\r\n\r\n            // Write with Write\r\n            else if (write_to_from.count(b) != 0)\r\n            {\r\n                result.push_back(&quot;WAIT&quot;);\r\n                clearAll();\r\n            }\r\n\r\n            write_from_to.insert(make_pair(a, b));\r\n            write_to_from.insert(make_pair(b, a));\r\n\r\n            result.push_back(command);\r\n        }\r\n\r\n        else if (command[0] == &#39;R&#39;)\r\n        {\r\n            index1 = command.find(&quot; &quot;);\r\n            a = command.substr(index1 + 1, command.length() - index1 - 1);\r\n\r\n            // Read with Write\r\n            if (write_to_from.count(a) != 0)\r\n            {\r\n                result.push_back(&quot;WAIT&quot;);\r\n                clearAll();\r\n            }\r\n\r\n            read.insert(a);\r\n            result.push_back(command);\r\n        }\r\n    }\r\n\r\n    for (int i = 0; i &lt; result.size(); i++)\r\n    {\r\n        cout &lt;&lt; result[i] &lt;&lt; &quot;\\n&quot;;\r\n    }\r\n}</code>\n        </deckgo-highlight-code>","title":"[C++] BOJ #20292 컨설팅","date":"2022. 02. 25","next":{"frontmatter":{"path":"/boj2812","title":"[C++] BOJ #2812 크게 만들기"}},"previous":{"frontmatter":{"path":"/boj1912","title":"[C++] BOJ #1912 연속합"}}}},
    "staticQueryHashes": ["3649515864"]}