{
    "componentChunkName": "component---src-templates-prob-solving-template-js",
    "path": "/boj11048",
    "result": {"pageContext":{"html":"<h2>문제</h2>\n<p>준규는 N×M 크기의 미로에 갇혀있다. 미로는 1×1크기의 방으로 나누어져 있고, 각 방에는 사탕이 놓여져 있다. 미로의 가장 왼쪽 윗 방은 (1, 1)이고, 가장 오른쪽 아랫 방은 (N, M)이다.</p>\n<p>준규는 현재 (1, 1)에 있고, (N, M)으로 이동하려고 한다. 준규가 (r, c)에 있으면, (r+1, c), (r, c+1), (r+1, c+1)로 이동할 수 있고, 각 방을 방문할 때마다 방에 놓여져있는 사탕을 모두 가져갈 수 있다. 또, 미로 밖으로 나갈 수는 없다.</p>\n<p>준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수의 최댓값을 구하시오.</p>\n<h3>입력</h3>\n<ul>\n<li>\n<p>첫째 줄에 미로의 크기 N, M이 주어진다. (1 ≤ N, M ≤ 1,000)</p>\n</li>\n<li>\n<p>둘째 줄부터 N개 줄에는 총 M개의 숫자가 주어지며, r번째 줄의 c번째 수는 (r, c)에 놓여져 있는 사탕의 개수이다. 사탕의 개수는 0보다 크거나 같고, 100보다 작거나 같다.</p>\n</li>\n</ul>\n<h3>출력</h3>\n<ul>\n<li>첫째 줄에 준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수를 출력한다.</li>\n</ul>\n<hr />\n<h4>1. 해결방법 및 소스코드</h4>\n<ul>\n<li>**동적 프로그래밍(Dynamic Programming)**으로 해결했다.</li>\n<li><code>dp[n][m]</code>을 구하는 것은 내가 해당 (N, M)칸의 입장이 된다고 생각하면 쉽다. 최종적으로 사탕을 많이 얻고싶은데, 다음 세 가지 중에서 최대값을 고르고 싶을 것이다.\n<ol>\n<li>한 칸 왼쪽까지 왔을때의 최대 사탕 개수 + 지금 칸의 사탕 개수</li>\n<li>한 칸 위쪽까지 왔을때의 최대 사탕 개수 + 지금 칸의 사탕 개수</li>\n<li>왼쪽대각선 위쪽(↖)까지 왔을때의 최대 사탕 개수 + 지금 칸의 사탕 개수</li>\n</ol>\n</li>\n<li>dp의 처음 맨 윗줄(0번 행)과 맨 왼쪽 줄(0번 열)은 그저 <code>왼쪽칸(위쪽칸)의 사탕개수 + 현재 칸의 사탕개수</code>만 해주면 최대이므로 그렇게 초기화해놓고 <code>dp[1][1]</code>부터 반복문으로 최종결과를 구한다.</li>\n</ul>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int N, M;\r\n    int maze[1000][1000];\r\n    int dp[1000][1000];\r\n    scanf(&quot;%d %d&quot;, &amp;N, &amp;M);\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        for (int j = 0; j &lt; M; j++)\r\n        {\r\n            scanf(&quot;%d&quot;, &amp;maze[i][j]);\r\n        }\r\n    }\r\n\r\n    dp[0][0] = maze[0][0];\r\n\r\n    for (int i = 1; i &lt; M; i++)\r\n    {\r\n        dp[0][i] = maze[0][i] + dp[0][i - 1];\r\n    }\r\n\r\n    for (int i = 1; i &lt; N; i++)\r\n    {\r\n        dp[i][0] = maze[i][0] + dp[i - 1][0];\r\n    }\r\n\r\n    for (int i = 1; i &lt; N; i++)\r\n    {\r\n        for (int j = 1; j &lt; M; j++)\r\n        {\r\n            dp[i][j] = maze[i][j] + max(max(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]);\r\n        }\r\n    }\r\n\r\n    printf(&quot;%d\\n&quot;, dp[N - 1][M - 1]);\r\n}</code>\n        </deckgo-highlight-code>","title":"[C++] BOJ #11048 이동하기","date":"2022. 02. 27","next":{"frontmatter":{"path":"/aboutdp","title":"동적 프로그래밍(Dynamic Programming)이란?"}},"previous":null}},
    "staticQueryHashes": ["3649515864"]}