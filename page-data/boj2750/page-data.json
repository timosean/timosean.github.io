{
    "componentChunkName": "component---src-templates-prob-solving-template-js",
    "path": "/boj2750",
    "result": {"pageContext":{"html":"<h2>문제</h2>\n<p>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.</p>\n<h3>입력</h3>\n<ul>\n<li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.</li>\n</ul>\n<h3>출력</h3>\n<ul>\n<li>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.</li>\n</ul>\n<hr />\n<h4>1. 기본 아이디어 및 소스코드</h4>\n<ul>\n<li>제한시간 1초이다. C++인 경우 시간복잡도가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> 이라고 할 때, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>이 1억이 되어야 1초가 걸린다고 들었다.</li>\n<li><strong>Bubble Sort</strong>의 시간복잡도는 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> 인데, 문제에서 최대 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>을 1,000까지만 주기 때문에 버블정렬을 써도 충분하다고 생각해서 버블정렬을 구현하였다.</li>\n<li>다른 정렬방법들에 비해서는 구현이 간단하지만 비효율적인 방법이다.</li>\n</ul>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nvoid bubbleSort(int numbers[], int N)\r\n{\r\n    int temp = 0;\r\n    for (int i = 0; i &lt; N - 1; i++)\r\n    {\r\n        for (int j = 0; j &lt; N - 1 - i; j++)\r\n        {\r\n            if (numbers[j] &gt; numbers[j + 1])\r\n            {\r\n                temp = numbers[j];\r\n                numbers[j] = numbers[j + 1];\r\n                numbers[j + 1] = temp;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int N;\r\n    scanf(&quot;%d&quot;, &amp;N);\r\n\r\n    int numbers[N];\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        scanf(&quot;%d&quot;, &amp;numbers[i]);\r\n    }\r\n\r\n    bubbleSort(numbers, N);\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        printf(&quot;%d\\n&quot;, numbers[i]);\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<br/>\n<h4>2. 다른 아이디어 및 소스코드</h4>\n<ul>\n<li><strong>Selection Sort</strong>로도 문제를 해결할 수 있다.</li>\n<li>마찬가지로 이 정렬 알고리즘도 시간복잡도가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span> 이다.</li>\n<li>따라서, 다른 정렬 알고리즘에 비해서는 구현이 간단하지만 비효율적이다.</li>\n</ul>\n<ol>\n<li>주어진 리스트 중에 (정렬이 되지 않은 남은 부분중에) 최솟값을 찾는다.</li>\n<li>그 값을 정렬이 안 된 부분 중 맨 앞의 값과 교체한다.</li>\n</ol>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nvoid selectionSort(int numbers[], int N)\r\n{\r\n    int temp, minidx;\r\n\r\n    for (int i = 0; i &lt; N - 1; i++)\r\n    {\r\n        minidx = i;\r\n\r\n        //남은 데이터들 중 최솟값을 가진 인덱스 찾기\r\n        for (int j = i + 1; j &lt; N; j++)\r\n        {\r\n            if (numbers[minidx] &gt; numbers[j])\r\n            {\r\n                minidx = j;\r\n            }\r\n        }\r\n\r\n        //최솟값을 찾았으면 numbers[i]와 자리 바꿔주기\r\n        temp = numbers[i];\r\n        numbers[i] = numbers[minidx];\r\n        numbers[minidx] = temp;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int N;\r\n    scanf(&quot;%d&quot;, &amp;N);\r\n\r\n    int numbers[N];\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        scanf(&quot;%d&quot;, &amp;numbers[i]);\r\n    }\r\n\r\n    selectionSort(numbers, N);\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        printf(&quot;%d\\n&quot;, numbers[i]);\r\n    }\r\n}</code>\n        </deckgo-highlight-code>","title":"[C++] BOJ #2750 수 정렬하기","date":"2022. 02. 12","next":{"frontmatter":{"path":"/boj2751","title":"[C++] BOJ #2751 수 정렬하기2"}},"previous":{"frontmatter":{"path":"/boj1927","title":"[C++] BOJ #1927 최소 힙"}}}},
    "staticQueryHashes": ["3649515864"]}