{
    "componentChunkName": "component---src-templates-prob-solving-template-js",
    "path": "/boj1754",
    "result": {"pageContext":{"html":"<h2>문제</h2>\n<p>히스토그램에 대해서 알고 있는가? 히스토그램은 아래와 같은 막대그래프를 말한다.</p>\n<p align=\"center\">\r\n<img alt=\"code_runner_img\" src=\"https://github.com/timosean/timosean.github.io/blob/master/postimages/hist1725.png?raw=true\">\r\n</p>\n<p>각 칸의 간격은 일정하고, 높이는 어떤 정수로 주어진다. 위 그림의 경우 높이가 각각 2 1 4 5 1 3 3이다.</p>\n<p>이러한 히스토그램의 내부에 가장 넓이가 큰 직사각형을 그리려고 한다. 아래 그림의 빗금 친 부분이 그 예이다. 이 직사각형의 밑변은 항상 히스토그램의 아랫변에 평행하게 그려져야 한다.</p>\n<p align=\"center\">\r\n<img alt=\"code_runner_img\" src=\"https://github.com/timosean/timosean.github.io/blob/master/postimages/histo1725.png?raw=true\">\r\n</p>\n<p>주어진 히스토그램에 대해, 가장 큰 직사각형의 넓이를 구하는 프로그램을 작성하시오.</p>\n<h3>입력</h3>\n<ul>\n<li>첫 행에는 N (1 ≤ N ≤ 100,000) 이 주어진다. N은 히스토그램의 가로 칸의 수이다. 다음 N 행에 걸쳐 각 칸의 높이가 왼쪽에서부터 차례대로 주어진다. 각 칸의 높이는 1,000,000,000보다 작거나 같은 자연수 또는 0이다.</li>\n</ul>\n<h3>출력</h3>\n<ul>\n<li>첫째 줄에 가장 큰 직사각형의 넓이를 출력한다. 이 값은 20억을 넘지 않는다.</li>\n</ul>\n<hr />\n<h4>1. 기본 아이디어 및 소스코드</h4>\n<ul>\n<li>\n<p>스택을 활용하여 해결한다.</p>\n</li>\n<li>\n<p>히스토그램 배열은 모두 0으로 초기화 되어있으며, 인덱스 <code>[1]</code>부터 <code>[N]</code>까지 높이들을 입력받는다.</p>\n</li>\n<li>\n<p>입력받은 배열에서 <code>for loop</code>을 돌며 중간중간 답을 구한다.</p>\n<ol>\n<li><code>hgram[i-1] &#x3C;= hgram[i]</code>이면 스택에 <code>i</code>를 쌓는다. (즉, 스택에는 직접 높이값을 저장하는 것이 아니라 히스토그램 배열의 인덱스를 저장)</li>\n<li>만약, <code>i</code>번째 높이가 <code>i-1</code>번째 높이보다 낮다면, 일단 흐름이 끊겼다고 볼 수 있으므로, 여태까지 나온 직사각형들에서 최대넓이를 구하는 과정을 들어간다.</li>\n</ol>\n</li>\n<li>\n<p>위의 2번에서 실행하는 <strong>현재까지 나온 직사각형들에서 최대넓이를 구하는 과정</strong>은 다음과 같다.</p>\n<ol>\n<li><code>check</code> 변수에 현재 스택의 <code>top</code>을 저장해둔다. (넓이를 구할 직사각형의 높이를 가지고 있는 인덱스를 저장)</li>\n<li>맨 위를 <code>pop</code>한다.</li>\n<li>C++의 <code>max</code>함수를 이용하여 현재까지 구해놓은 최댓값과 지금 구한 직사각형의 넓이와 비교하여 최댓값을 업데이트한다.\r\n직사각형의 넓이는 <code>hgram[check] * (i - s.top() - 1)</code>로 구할 수 있다.</li>\n</ol>\n</li>\n<li>\n<p>자세한 아이디어는 <a href=\"https://cocoon1787.tistory.com/315\">https://cocoon1787.tistory.com/315</a> 포스트의 그림을 참고하여 이해 가능하다.</p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;stack&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int N, ans = 0;\r\n    int hgram[100005] = {\r\n        0,\r\n    };\r\n    stack&lt;int&gt; s;\r\n\r\n    //스택이 비어서 오류 나는 경우 방지\r\n    s.push(0);\r\n\r\n    scanf(&quot;%d&quot;, &amp;N);\r\n\r\n    //히스토그램 채우기 (인덱스는 1부터)\r\n    for (int i = 1; i &lt;= N; i++)\r\n        scanf(&quot;%d&quot;, &amp;hgram[i]);\r\n\r\n    //해답 구하는 과정\r\n    for (int i = 1; i &lt;= N + 1; i++)\r\n    {\r\n        //스택의 맨 위의 인덱스에 해당하는 높이보다 현재 높이가 낮으면 계속 pop한다.\r\n        while (!s.empty() &amp;&amp; hgram[i] &lt; hgram[s.top()])\r\n        {\r\n            int check = s.top();\r\n            s.pop();\r\n            ans = max(ans, hgram[check] * (i - s.top() - 1));\r\n        }\r\n\r\n        s.push(i);\r\n    }\r\n\r\n    printf(&quot;%d\\n&quot;, ans);\r\n}</code>\n        </deckgo-highlight-code>","title":"[C++] BOJ #1725 히스토그램","date":"2022. 02. 11","next":{"frontmatter":{"path":"/boj2164","title":"[C++] BOJ #2164 카드2"}},"previous":{"frontmatter":{"path":"/boj2750","title":"[C++] BOJ #2750 수 정렬하기"}}}},
    "staticQueryHashes": ["3649515864"]}