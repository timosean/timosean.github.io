{
    "componentChunkName": "component---src-templates-prob-solving-template-js",
    "path": "/boj2751",
    "result": {"pageContext":{"html":"<h2>문제</h2>\n<p>N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.</p>\n<h3>입력</h3>\n<ul>\n<li>첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.</li>\n</ul>\n<h3>출력</h3>\n<ul>\n<li>첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.</li>\n</ul>\n<hr />\n<h4>1. 기본 아이디어 및 소스코드</h4>\n<ul>\n<li>\n<p>제한시간 2초이다. C++인 경우 시간복잡도가 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"mclose\">)</span></span></span></span></span> 이라고 할 때, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>N</mi></mrow><annotation encoding=\"application/x-tex\">N</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6833em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span>이 1억이 되어야 1초가 걸린다고 들었다.</p>\n</li>\n<li>\n<p>따라서, 최소한 시간복잡도가 선형 이하인 정렬 알고리즘을 골라서 사용해야한다.</p>\n</li>\n<li>\n<p>그것을 만족하는 정렬 알고리즘은 <strong>Merge Sort</strong>이다.</p>\n</li>\n<li>\n<p>Merge Sort는 시간복잡도가 항상 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(nlogn)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">n</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathnormal\">n</span><span class=\"mclose\">)</span></span></span></span></span> 을 내는 알고리즘으로 Heap Sort와 같고, 최악상황의 Quick Sort(<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.0641em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathnormal\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span></span>)보다 안정적이다.</p>\n</li>\n<li>\n<p>Merge Sort는 <code>분할 정복(Divide and Conquer)</code> 방법을 사용한다. 이 방법은 대개 <code>재귀 호출</code>을 많이 사용한다. 과정은 다음과 같다.</p>\n<ol>\n<li>리스트의 길이가 0 또는 1이면 이미 정렬된 것으로 본다. 그렇지 않은 경우에는</li>\n<li>정렬되지 않은 리스트를 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다.</li>\n<li>각 부분 리스트를 재귀적으로 Merge Sort를 이용해 정렬한다.</li>\n<li>두 부분 리스트를 다시 하나의 정렬된 리스트로 병합한다.</li>\n</ol>\n</li>\n</ul>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nvoid areaMerge(int numbers[], int left, int mid, int right)\r\n{\r\n    int fIdx = left;\r\n    int rIdx = mid + 1;\r\n\r\n    int *sortArr = (int *)malloc(sizeof(int) * (right + 1));\r\n    int sIdx = left;\r\n\r\n    while (fIdx &lt;= mid &amp;&amp; rIdx &lt;= right)\r\n    {\r\n        if (numbers[fIdx] &lt; numbers[rIdx])\r\n        {\r\n            sortArr[sIdx] = numbers[fIdx++];\r\n            sIdx++;\r\n        }\r\n        else\r\n        {\r\n            sortArr[sIdx] = numbers[rIdx++];\r\n            sIdx++;\r\n        }\r\n    }\r\n\r\n    if (fIdx &gt; mid)\r\n    {\r\n        for (int i = rIdx; i &lt;= right; i++)\r\n        {\r\n            sortArr[sIdx++] = numbers[i];\r\n        }\r\n    }\r\n    else\r\n    {\r\n        for (int i = fIdx; i &lt;= mid; i++)\r\n        {\r\n            sortArr[sIdx++] = numbers[i];\r\n        }\r\n    }\r\n\r\n    for (int i = left; i &lt;= right; i++)\r\n    {\r\n        numbers[i] = sortArr[i];\r\n    }\r\n\r\n    free(sortArr);\r\n}\r\n\r\nvoid mergeSort(int numbers[], int left, int right)\r\n{\r\n    int mid;\r\n\r\n    if (left &lt; right)\r\n    {\r\n        mid = (left + right) / 2;\r\n        mergeSort(numbers, left, mid);\r\n        mergeSort(numbers, mid + 1, right);\r\n\r\n        areaMerge(numbers, left, mid, right);\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int N;\r\n    scanf(&quot;%d&quot;, &amp;N);\r\n\r\n    int numbers[N];\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        scanf(&quot;%d&quot;, &amp;numbers[i]);\r\n    }\r\n\r\n    mergeSort(numbers, 0, N - 1);\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        printf(&quot;%d\\n&quot;, numbers[i]);\r\n    }\r\n}</code>\n        </deckgo-highlight-code>","title":"[C++] BOJ #2751 수 정렬하기2","date":"2022. 02. 12","next":{"frontmatter":{"path":"/boj1754","title":"[C++] BOJ #1725 히스토그램"}},"previous":{"frontmatter":{"path":"/boj2750","title":"[C++] BOJ #2750 수 정렬하기"}}}},
    "staticQueryHashes": ["3649515864"]}