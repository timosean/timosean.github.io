{
    "componentChunkName": "component---src-templates-devlog-template-js",
    "path": "/class101-challenge",
    "result": {"pageContext":{"html":"<h2>💻CLASS101 프론트엔드 클론코딩 챌린지</h2>\n<p>여느 때처럼 인스타그램 스토리를 훑어보던 중, 스토리들 사이에 낀 광고 하나를 보게되었다.<br/>\r\n무심코 스와이프했다가 \"프론트엔드 챌린지\" 라고 쓰여있었던 것 같아 얼른 다시 그 광고로 돌아왔다.<br/>\r\n<br/>\r\n마침 이 Todylog를 완성하고 다음으로 무엇을 할지 고민하고 있던 차에 아주 좋은 챌린지 기회가 찾아왔던 것이다!\r\n참가비도 1만원으로 부담 없었고, 이마저도 제출만 한다면 돌려준다니 아주 열정적인 10일을 보낼 기회가 찾아왔다.<br/>\r\n(게다가 상위 10% 안에 들면 개발자님들의 코드리뷰와(10만원보단 코드리뷰 받지 않을까싶다) 개발자 풀에 초대해주신다니 열심히 참여할 계기도 충분했다.)<br/>\r\n<br/>\r\n고민할 필요도 없이 바로 신청했고, 그 후기를 아래에 남기겠다 :-)</p>\n<hr/>\n<h3>[1] 개발 과정에서 고민했던 것들</h3>\n<h4>(1) TypeScript × Styled-Components</h4>\n<p><strong>[설치]</strong><br>\nJavaScript × React로 Styled-Components를 설치할 때와 똑같이 설치해주었는데 자꾸 오류가 났다.<br>\n찾아보니 TypeScript로 Styled-Components를 설치할 때는 다음과 같이 설치해야 한다고 한다.</p>\n<pre><code>yarn add styled-components @types/styled-components\n</code></pre>\n<p><strong>[props 전달]</strong><br>\n이전에도 Styled-Components 를 많이 써왔지만 TypeScript 자체가 처음이기 때문에 props 전달하는 문법이 따로 있다는 것을 몰랐다.\r\nStyled-Component에게 <ComponentName propsName={propsValue} />와 같이 그냥 props를 전달하였더니 다음과 같은 오류가 발생했다.</p>\n<blockquote>\n<p><strong>이 호출과 일치하는 오버로드가 없습니다</strong></p>\n</blockquote>\n<p>Styled-Components에게 props를 전달하려면 Styled-Component를 선언할 때 다음과 같이 작성해주어야 했다.\r\n(단일 props일 경우에 아래와 같이 작성한다. 전달할 props가 많으면 interface를 작성해야 한다고 한다.)</p>\n<pre><code>const ComponentName = styled.div&#x3C;{propsName: 해당Type}>`\r\n  style here\r\n`\n</code></pre>\n<p>예를 들면 다음과 같다.</p>\n<pre><code>const StyledNavbar = styled.div&#x3C;{isOpened: boolean}>`\r\n  style here\r\n `\n</code></pre>\n<br/>\n<h4>(2) 테두리를 없앴는데 테두리가 생긴다..</h4>\n<p>CLASS101 사이트의 검색창을 누르면 다음과 같이 검색창 테두리에 아무런 변화가 없다.<br>\n<img alt=\"CLASS101 검색창\" src=\"https://raw.githubusercontent.com/timosean/timosean.github.io/0fdb210c89106f7cd1498ce35e19235bdd9d11ee/postimages/prob2.png\"/></p>\n<p>하지만 분명 <code>border: none;</code>을 주었는데도 불구하고 검색창을 클릭하면 검은 테두리가 활성화되었다.</p>\n<p>이는 input 태그의 focus 상태에서의 스타일링에서 아웃라인을 없애주면 해결이 된다.\r\n나는 styled-components를 사용하였기 때문에 컴포넌트 내부에서 다음과 같이 스타일링 해주었다.</p>\n<pre><code>const StyledInput = styled.input&#x3C;{ isOpened: boolean }>`\r\n\r\n  many codes here...\r\n\r\n  &#x26;:focus {\r\n    outline: none;\r\n  }\r\n`;\n</code></pre>\n<br/>\n<h4>(3) flexbox 속의 개별 요소 하나를 스타일링하기</h4>\n<p>CLASS101 사이트 상단 내비게이션 바에 '1월 가입혜택'을 보면 빨간 뱃지가 우상단에 달려있다.</p>\n<p align=\"center\">\r\n<img alt=\"1월 가입혜택 이미지\" src=\"https://raw.githubusercontent.com/timosean/timosean.github.io/0fdb210c89106f7cd1498ce35e19235bdd9d11ee/postimages/prob3.png\">\r\n</p>\n<p>하지만 내가 빨간 뱃지를 만들고 배치했을 때에는 계속 전체 높이의 중간에만 위치되었다.<br>\n아마 flexbox의 <code>align-items: center;</code> 속성 때문인 것 같았다.<br>\n그렇게 flexbox의 개별 아이템을 따로 포지셔닝 할 수 있는 방법을 찾다가 다음과 같은 속성을 발견했다.<br>\n바로 <code>align-self</code> 속성이다.<br>\n<br/></p>\n<p><code>align-self</code> 속성의 기본값은 <code>auto</code>로, <code>align-items</code>의 값을 그대로 물려받는다.<br>\n따라서, 특정 아이템의 정렬을 따로 정하고 싶다면, <code>align-self: flex-start;</code>와 같이 따로 명시해주어야 한다.\r\n이렇게 해서 빨간 뱃지를 위의 그림처럼 맨 위로 올릴 수 있게 되었다.</p>\n<p>마찬가지로, <code>justify-self</code> 속성도 있다.</p>\n<br/>\n<h4>(4) TypeScript 에러: Undefined 일 수도 있습니다..?</h4>\n<p>'전체 카테고리' 메뉴를 hover 했을 때 나오는 드롭다운 리스트에서의 각각의 메뉴를 hover 했을 때,<br>\n해당 메뉴의 세부 메뉴 리스트가 옆에 등장해야 한다. (아래 그림과 같다.)</p>\n<p align=\"center\"> \r\n<img alt=\"dropdown_img\" src=\"https://raw.githubusercontent.com/timosean/timosean.github.io/0fdb210c89106f7cd1498ce35e19235bdd9d11ee/postimages/prob4.png\">\r\n</p>\n<p>이를 구현하기 위해서, 드롭다운 리스트에 필요한 정보를 다음과 같이 객체 배열로 만들었다.</p>\n<pre><code>const CategoryMenus = [\r\n  {\r\n    id: 1,\r\n    name: \"디지털 드로잉\",\r\n    to: \"https://class101.net/search?category=604f1c9756c3676f1ed0030e\",\r\n    submenus: [\r\n      {\r\n        id: 11,\r\n        name: \"일러스트\",\r\n        to: \"https://class101.net/search?category=613070fa5b76158cac88344a\",\r\n      },\r\n      {\r\n        id: 12,\r\n        name: \"컨셉아트\",\r\n        to: \"https://class101.net/search?category=6114891dfe1ca7f7b31b4a23\",\r\n      },\r\n      {\r\n        id: 13,\r\n        name: \"캐릭터 드로잉\",\r\n        to: \"https://class101.net/search?category=613070fa5b76158cac88344b\",\r\n      },\r\n      {\r\n        id: 14,\r\n        name: \"인물 드로잉\",\r\n        to: \"https://class101.net/search?category=613070fa5b76158cac88344c\",\r\n      },\r\n      {\r\n        id: 15,\r\n        name: \"굿즈 · 이모티콘\",\r\n        to: \"https://class101.net/search?category=613070fa5b76158cac88344d\",\r\n      },\r\n      {\r\n        id: 16,\r\n        name: \"웹툰\",\r\n        to: \"https://class101.net/search?category=613070fa5b76158cac88344e\",\r\n      },\r\n      {\r\n        id: 17,\r\n        name: \"캘리그라피\",\r\n        to: \"https://class101.net/search?category=613070fa5b76158cac88344f\",\r\n      },\r\n      {\r\n        id: 18,\r\n        name: \"더 새로운 디지털 드로잉\",\r\n        to: \"https://class101.net/search?category=613070fa5b76158cac883450\",\r\n      },\r\n    ],\r\n  },\r\n  {\r\n    id: 2,\r\n    name: \"드로잉\",\r\n    to: \"https://class101.net/search?category=604f1c9756c3676f1ed00304\",\r\n    submenus: [\r\n      {\r\n        id: 20,\r\n        name: \"펜 · 연필\",\r\n        to: \"https://class101.net/search?category=604f1c9756c3676f1ed00305\",\r\n      },\r\n      {\r\n        id: 21,\r\n        name: \"마카\",\r\n        to: \"https://class101.net/search?category=604f1c9756c3676f1ed00306\",\r\n      },\r\n      {\r\n        id: 22,\r\n        name: \"색연필\",\r\n        to: \"https://class101.net/search?category=604f1c9756c3676f1ed00307\",\r\n      },\r\n      {\r\n        id: 23,\r\n        name: \"수채화\",\r\n        to: \"https://class101.net/search?category=604f1c9756c3676f1ed00308\",\r\n      },\r\n      {\r\n        id: 24,\r\n        name: \"오일파스텔\",\r\n        to: \"https://class101.net/search?category=604f1c9756c3676f1ed00309\",\r\n      },\r\n      {\r\n        id: 25,\r\n        name: \"과슈 · 아크릴화\",\r\n        to: \"https://class101.net/search?category=604f1c9756c3676f1ed0030a\",\r\n      },\r\n      {\r\n        id: 26,\r\n        name: \"유화\",\r\n        to: \"https://class101.net/search?category=604f1c9756c3676f1ed0030b\",\r\n      },\r\n      {\r\n        id: 27,\r\n        name: \"동양화\",\r\n        to: \"https://class101.net/search?category=604f1c9756c3676f1ed0030c\",\r\n      },\r\n      {\r\n        id: 28,\r\n        name: \"캘리그라피\",\r\n        to: \"https://class101.net/search?category=604f1c9756c3676f1ed00312\",\r\n      },\r\n      {\r\n        id: 29,\r\n        name: \"더 새로운 드로잉\",\r\n        to: \"https://class101.net/search?category=604f1c9756c3676f1ed0030d\",\r\n      },\r\n    ],\r\n  },\r\n\r\n  ...And more objects...\n</code></pre>\n<p>Array.map을 이용하여 '전체 카테고리'를 hover했을 때 나타나는 드롭다운 리스트를 만들고,<br>\n여기에서 hover한 메뉴 이름을 useState로 저장해놓고, 위의 객체 배열에서 name이 state에 저장되어 있는 이름과 같은 객체를 찾아서 submenus를 다시 map 해주는 식으로 구현했다.<br>\n어차피 state에 저장되어있는 이름과 name값이 같은 객체는 한 개 뿐이므로, Array.find 메소드 (주어진 판별 함수를 만족하는 첫 번째 요소를 반환) 를 사용하여 다음과 같이 구현하려고 했다.</p>\n<pre><code>const [categoryName, setCategoryName] = useState(\"\");\r\n\r\n//전체 카테고리 드롭다운 리스트\r\n//여기에서 hover한 메뉴의 이름이 onMouseEnter 이벤트를 통해 categoryName에 저장된다.\r\n     ...code...\r\n\r\n//우측에 나타나는 서브메뉴 리스트\r\n&#x3C;DropdownSection>\r\n     &#x3C;SectionTitle element=\"h2\">{categoryName}&#x3C;/SectionTitle>\r\n          {CategoryMenus.find(\r\n               (menu) => menu.name === categoryName\r\n               ).submenus.map((submenu) => (\r\n               &#x3C;AdditionalSectionItem\r\n                    key={submenu.id}\r\n                    to={submenu.to}\r\n                    className=\"sectionItem\"\r\n               >\r\n                    {submenu.name}\r\n                  &#x3C;/AdditionalSectionItem>\r\n          ))}\r\n&#x3C;/DropdownSection>\n</code></pre>\n<p>그러나 다음과 같은 에러가 발생했다.</p>\n<blockquote>\n<p><strong>Object is possibly 'undefined'</strong></p>\n</blockquote>\n<p>이것은 타입스크립트를 사용해서 발생한 문제로, 타입스크립트가 값이 undefined 일 수도 있다고 판단한 요소 뒤에 옵셔널 체이닝 연산자 <code>?.</code>를 추가하면 정상적으로 출력되는 것을 확인할 수 있다.<br>\n위 코드에서 <code>CategoryMenus.find((menu) => menu.name === categoryName)?.submenus.map ~~</code><br>\n이렇게 고쳐주었다.</p>\n<br/>\n<h4>(5) hover도 좋지만 MouseEvent를 적극 활용하자</h4>\n<p>이 Todylog를 개발하면서 마우스 관련 이벤트는 css <code>:hover</code>만으로 해결되는 경우가 다였어서 <code>:hover</code>밖에 생각이 안났었는데<br>\n마우스를 올리거나 뗐을 때 등등 마우스 관련 수많은 event들이 있다는 것을 생각해냈다😂 (너무 당연한건데... 더 열심히 해야겠음)<br>\n<code>onMouseEnter</code>와 <code>onMouseLeave</code> 이벤트가 일어날 때 isMenuOpened라는 state의 상태를 바꿔주는 식으로 구현했다.<br>\n아래는 예시코드이다.</p>\n<pre><code>const [isMenuOpened, setMenuOpened] = useState(false);\r\n\r\n&#x3C;Button onMouseEnter={() => setMenuOpened(true)} onMouseLeave={() => setMenuOpened(false)}>\n</code></pre>\n<p>위 (4)번의 그림에서 보듯이 '전체 카테고리'에 마우스를 올리면 드롭다운 리스트가 나타나고, 이 리스트에서 마우스를 바깥으로 옮기면 다시 리스트가 사라진다.\r\n처음에는 단순하게 '전체 카테고리' 버튼에 <code>onMouseEnter</code>와 <code>onMouseLeave</code>를 둘 다 걸어주었는데, 이렇게 했더니 (너무 당연하지만)\r\n드롭다운 리스트가 나타나고, 사용자가 드롭다운 메뉴에 마우스를 올리려고 하는 순간 마우스가 '전체 카테고리' 버튼을 벗어나게 되면서 드롭다운 리스트가 사라져버렸다.\r\n(약 올리는 것도 아니고🤣)</p>\n<p>이런 문제를 개선하기 위해서 '전체 카테고리' 버튼에는 <code>onMouseLeave</code> 이벤트를 걸어주지 않고, 드롭다운 리스트에 <code>onMouseLeave</code> 이벤트를 걸어주었다.</p>\n<br/>\n<h4>(6) position: relative / absolute 활용하기</h4>\n<p>위 (4)번의 그림처럼 전체 카테고리 드롭다운의 메뉴에 마우스를 올리면 해당 메뉴의 세부메뉴 리스트가 옆에 등장한다.<br>\n이걸 구현하는 데에 있어서 처음에는 다음과 같이 구현했었다.</p>\n<pre><code>&#x3C;MainDropDownList onMouseEnter={() => setMenuOpened(true)} onMouseLeave={() => setMenuOpened(false)}>\r\n  &#x3C;SubMenu onMouseEnter={() => setSubmenuOpened(true)}>\r\n&#x3C;MainDropDownList />\r\n\r\n&#x3C;SubMenuList onMouseLeave={() => setSubmenuOpened(false)}/>\n</code></pre>\n<p>여기에서 문제는, MainDropDownList에서 마우스가 떠나면 서브메뉴 리스트도 화면에서 사라져야 하는데, MainDropDownList만 화면에서 사라지고,\r\n서브메뉴 리스트는 화면에 남아 둥둥 떠있게 되었다.<br>\nMainDropDownList에서 마우스가 떠날 때 서브메뉴 리스트도 없어지게 만드려면 서브메뉴 리스트를 MainDropDownList의 자식으로 넣어야되겠다는\r\n생각이 들었다.</p>\n<p>마침 MainDropDownList의 position 속성도 <code>position: relative;</code> 였어서, 서브메뉴 리스트의 포지션을 <code>position: absolute;</code>를 주고,\r\n부모인 MainDropDownList에 상대적으로 <code>top</code>속성과 <code>left</code>속성을 주어 위치를 조절하면 되겠다는 생각이 들었고, 이렇게해서 해결할 수 있게 되었다.</p>\n<br/>\n<h4>(7) document.getElementById 활용하기</h4>\n<p>아래의 그림처럼 전체 카테고리 드롭다운에서 한 카테고리에 마우스를 올린 후 해당 세부메뉴 리스트로 마우스를 옮기게 되면, 전체 카테고리 드롭다운에서 선택된 카테고리의 글자가 진해지면서 오른편에 화살표가 나타나게 된다.</p>\n<p align=\"center\"> \r\n<img alt=\"dropdown_img\" src=\"https://raw.githubusercontent.com/timosean/timosean.github.io/484ba5500915f93798a38dba3e083e521a3e5eac/postimages/prob7.png\">\r\n</p>\n<p>그래서 생각한 로직은, 일단 각 카테고리의 아이콘에 id를 해당 카테고리 이름으로 주고, 세부메뉴 리스트에 <code>onMouseEnter</code> 시에 <code>document.getElementById</code>로 해당\r\n아이콘을 선택한 다음, <code>style.visibility=\"visible\"</code>을 주는 것이다.<br>\n(물론, 아이콘의 스타일을 정의할 때 <code>visibility</code>는 <code>hidden</code>으로 주었다.)<br>\n그리고, 당연히 세부메뉴 리스트에 <code>onMouseLeave</code> 시에는 다시 <code>style.visibility=\"hidden\"</code>을 주어야 다른 카테고리를 선택했을 때에 그 카테고리의 화살표만\r\n남아있게 된다.</p>\n<p>마찬가지로, 카테고리 이름을 감싸는 컴포넌트에도 id를 주는데, 아이콘의 id와 공통된 단어가 들어가게 해줌으로써, 함수 하나에서 템플릿 리터럴을 이용하여\r\n해결할 수 있게 했다. (다음의 코드 참고)</p>\n<pre><code>//아이콘 visibility를 조절하는 함수\r\nconst makeIconAppear = (name: string) => {\r\n  document.getElementById(name).style.visibility = \"visible\";\r\n  document.getElementById(`link-${name}`).style.fontWeight = \"bold\";\r\n};\r\nconst makeIconDisappear = (name: string) => {\r\n  document.getElementById(name).style.visibility = \"hidden\";\r\n  document.getElementById(`link-${name}`).style.fontWeight = \"normal\";\r\n};\r\n\r\n//해당 컴포넌트 코드\r\n&#x3C;DropdownSection>\r\n  &#x3C;SectionTitle element=\"h2\">크리에이티브&#x3C;/SectionTitle>\r\n  {CategoryMenus.slice(0, 9).map((menu) => (\r\n    &#x3C;div\r\n      onMouseEnter={() => {\r\n      setCategoryName(`${menu.name}`);\r\n      setSubmenuHover(true);\r\n      }}\r\n      key={menu.id}\r\n    >\r\n      &#x3C;SectionItem className=\"sectionItem\">\r\n        &#x3C;SectionLink href={menu.to} id={`link-${menu.name}`}>\r\n          {menu.name}\r\n        &#x3C;/SectionLink>\r\n        &#x3C;RightIcon id={menu.name}>\r\n          &#x3C;ChevronRightIcon size={12} />\r\n        &#x3C;/RightIcon>\r\n      &#x3C;/SectionItem>\r\n    &#x3C;/div>\r\n  ))}\r\n&#x3C;/DropdownSection>\n</code></pre>\n<br/>\n<h4>(8) class 활용하기, TypeScript에서 e.target 사용하기</h4>\n<p>아래의 그림처럼, Bottom Navigation에서 클릭한(선택한) 부분만 색상이 변하고 나머지는 다 원래의 검정색으로 복구시키는 기능을\r\n구현해야했다. 무척이나 구현해보고 싶었지만 아이디어도 떠오르지 않았고 시도해 본 적도 없는 기능이어서 고민을 많이했다.</p>\n<p align=\"center\"> \r\n<img alt=\"bottomnav_img\" src=\"https://raw.githubusercontent.com/timosean/timosean.github.io/02e467c66274a12eafa99ad5f3cd7ef2f6d5815a/postimages/prob8.png\">\r\n</p>\n<p>그러다가, 클릭된 버튼을 event.target으로 가져와서, 그 버튼에 'isActive'라는 클래스 이름을 부여해주는 식으로 접근해보았다.\r\n물론 해당 버튼의 styled-components의 스타일에는 다음과 같이 isActive 클래스에 글자색을 바꿔주는 식으로 스타일링했다.</p>\n<pre><code>const StyledButton = styled.span`\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n  flex: 1 1 0%;\r\n  cursor: pointer;\r\n  text-decoration: none;\r\n  color: rgb(26, 26, 26);\r\n\r\n  &#x26;.isActive {\r\n    color: rgb(255, 61, 0);\r\n  }\r\n`;\n</code></pre>\n<p>우선, 클릭된 버튼을 event.target 으로 가져와서 클래스이름을 추가로 부여해주는 함수 코드는 다음과 같이 작성하였다.</p>\n<pre><code>const addClassName = (e: React.MouseEvent&#x3C;HTMLElement>) : void => {\r\n\te.target.classList.add('isActive');\r\n}\n</code></pre>\n<p>이렇게 했는데, 타입스크립트에서 다음과 같은 에러가 발생했다.</p>\n<blockquote>\n<p><strong>'EventTarget' 형식에 'classList' 속성이 없습니다</strong></p>\n</blockquote>\n<p>열심히 서칭해본 결과, TypeScript에서는 다음과 같이 <code>as</code>를 사용해서 타입캐스팅을 해주면 오류가 해결된다는 글을 보았다.</p>\n<pre><code>  const addClassName = (e: React.MouseEvent&#x3C;HTMLElement>) : void => {\r\n    const target = e.target as HTMLSpanElement;\r\n    const {classList} = target;\r\n  }\n</code></pre>\n<p>그렇게 해서 e.target의 classList를 뽑아내는 것까지 성공하고, 그 이후에 add와 remove 메서드도 사용할 수 있게 되었다.\r\n해당 컴포넌트와 함수 코드는 다음과 같다.</p>\n<pre><code>//해당 버튼 컴포넌트 구조\r\nconst StyledButton = styled.span`\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center;\r\n  align-items: center;\r\n  flex: 1 1 0%;\r\n  cursor: pointer;\r\n  text-decoration: none;\r\n  color: rgb(26, 26, 26);\r\n\r\n  &#x26;.isActive {\r\n    color: rgb(255, 61, 0);\r\n  }\r\n`;\r\n\r\n//StyledButton의 자식요소이므로, 버튼의 color 속성을 물려받도록 color: inherit 설정\r\nconst ContentName = styled.div`\r\n  font-size: 9px;\r\n  font-weight: 600;\r\n  color: inherit;\r\n  line-height: 12px;\r\n  letter-spacing: normal;\r\n  margin: 0px;\r\n`;\r\n\r\n//StyledButton의 자식요소이므로, 버튼의 color 속성을 물려받도록 color: inherit 설정\r\nconst IconArea = styled.span`\r\n  color: inherit;\r\n  font-size: 22px;\r\n`;\r\n\r\n&#x3C;StyledButton\r\n  onClick={(e) => {\r\n    setOpened(false);\r\n    addClassName(e);\r\n  }}\r\n>\r\n  &#x3C;IconArea className=\"classBtn\">\r\n    &#x3C;AiOutlinePlaySquare />\r\n  &#x3C;/IconArea>\r\n  &#x3C;div className=\"spacingBox\"> &#x3C;/div>\r\n  &#x3C;ContentName className=\"classBtn\">클래스&#x3C;/ContentName>\r\n&#x3C;/StyledButton>\r\n\r\n\r\n  const addClassName = (e: React.MouseEvent&#x3C;HTMLElement>): void => {\r\n    //일단 지금 오렌지색으로 변해있는 것의 isActive 클래스를 지우고\r\n    const removeTarget = document.querySelector(\".isActive\");\r\n    removeTarget?.classList.remove(\"isActive\");\r\n\r\n    //현재 선택된 버튼에 isActive 클래스를 추가해 오렌지색으로 바꾼다.\r\n    const target = e.target as HTMLSpanElement;\r\n    const { classList } = target;\r\n    classList.add(\"isActive\");\r\n  };\n</code></pre>\n<br/>\n<h4>(9) 포인터 이벤트의 대상이 되고 싶지 않다면? pointer-events: none;</h4>\n<p>위 (8)번의 문제를 해결하고 나니 문제가 하나 더 발생했다. 위 코드에서처럼 가장 바깥쪽 span(즉, StyledButton 컴포넌트)에 onClick 이벤트를\r\n준 것을 볼 수 있다. 이렇게 해당 영역을 클릭하면 StyledButton의 color 속성이 바뀌고 그 안의 아이콘과 글자의 color는 inherit이므로 저절로 바뀌도록\r\n해놓은 것이다.<br>\n하지만, 버튼 안의 아이콘과 텍스트를 클릭하면 색이 변하지 않고, StyledButton의 아이콘과 텍스트를 제외한 나머지 영역을 클릭해야 아이콘과 텍스트의 색이\r\n바뀌는 문제가 발생했다. <strong>사용자는 분명 아이콘을 클릭할텐데 말이다!</strong></p>\n<p align=\"center\"> \r\n<img alt=\"bottomnav_img\" src=\"https://raw.githubusercontent.com/timosean/timosean.github.io/0fdb210c89106f7cd1498ce35e19235bdd9d11ee/postimages/prob10.png\">\r\n</p>\n<p>그래서 아이콘과 텍스트가 클릭되어도 무시하고 StyledButton이 클릭되도록 하는 방법을 검색해본 결과, 예상 외로 상당히 간단하게 CSS로 해결할 수 있는\r\n부분이었다. 아이콘과 텍스트에 <code>pointer-events: none;</code>을 주면 아무리 그 위를 클릭해도 무시되고, 대신 부모요소가 클릭된다.</p>\n<pre><code>//pointer-events: none 추가\r\n\r\nconst ContentName = styled.div`\r\n  font-size: 9px;\r\n  font-weight: 600;\r\n  color: inherit;\r\n  line-height: 12px;\r\n  letter-spacing: normal;\r\n  margin: 0px;\r\n  pointer-events: none;\r\n`;\r\n\r\nconst IconArea = styled.span`\r\n  color: inherit;\r\n  font-size: 22px;\r\n  pointer-events: none;\r\n`;\n</code></pre>","title":"클론코딩 챌린지","date":"January 12, 2022","next":{"frontmatter":{"path":"/devtest2","title":"dev테스트2"}},"previous":null}},
    "staticQueryHashes": ["3649515864"]}