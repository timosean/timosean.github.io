{
    "componentChunkName": "component---src-templates-prob-solving-template-js",
    "path": "/boj1931",
    "result": {"pageContext":{"html":"<h2>문제</h2>\n<p>한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.</p>\n<h3>입력</h3>\n<ul>\n<li>첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding=\"application/x-tex\">2^{31}-1</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8974em;vertical-align:-0.0833em;\"></span><span class=\"mord\"><span class=\"mord\">2</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">31</span></span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">1</span></span></span></span></span> 보다 작거나 같은 자연수 또는 0이다.</li>\n</ul>\n<h3>출력</h3>\n<ul>\n<li>첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.</li>\n</ul>\n<hr />\n<h4>1. 해결방법 및 소스코드</h4>\n<ul>\n<li>최소 힙을 기반으로 한 우선순위 큐(Priority Queue)를 이용하였다.</li>\n<li>회의목록을 받았을 때, <strong>끝나는 시간이 빠른 순으로 정렬</strong>해야 회의목록을 훑어내려가면서 더 많은 회의들을 진행할 수 있겠다는 생각을 했다.</li>\n<li>만약 끝나는 시간이 같다면 시작하는 시간이 빠른 순으로 정렬해야 <strong>시작시간과 끝 시간이 같은 회의</strong>가 나와도 그것을 카운트하고 넘어갈 수 있다.</li>\n<li>따라서, 우선순위 큐에서 <code>greater&#x3C;pair&#x3C;int, int>></code>를 사용할 것이기 때문에 원소들을 받을 때 pair로<br>\n<strong>(끝시간, 시작시간)</strong> 을 받았다.</li>\n<li>마지막으로 담은 회의의 끝 시간을 저장하여 그 다음 회의시작시간이 그 이후인지를 판별한 후 카운트를 올려주고, 그 회의를 큐에서 pop한다. 만약 그 다음 회의시작시간이 마지막으로 담은 회의의 끝 시간보다 이르다면 카운트 해주지 말고\r\n그저 큐에서 pop만 하면 된다.</li>\n</ul>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int N, start, end;\r\n    int count = 0;\r\n    priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; confList;\r\n\r\n    scanf(&quot;%d&quot;, &amp;N);\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        scanf(&quot;%d %d&quot;, &amp;start, &amp;end);\r\n        confList.push(make_pair(end, start));\r\n    }\r\n\r\n    start = 0, end = 0;\r\n\r\n    while (!confList.empty())\r\n    {\r\n        //만약 회의실 우선순위 큐에서 가장 위에있는 회의의 시작시간이\r\n        //현재 가장 마지막으로 끝난 회의의 시간보다 뒤라면 그 회의는 시작 가능하다.\r\n        if (confList.top().second &gt;= end)\r\n        {\r\n            start = confList.top().second;\r\n            end = confList.top().first;\r\n            count++;\r\n            confList.pop();\r\n        }\r\n        else\r\n        {\r\n            confList.pop();\r\n        }\r\n    }\r\n\r\n    printf(&quot;%d\\n&quot;, count);\r\n}\r\n</code>\n        </deckgo-highlight-code>","title":"[C++] BOJ #1931 회의실 배정","date":"2022. 02. 23","next":{"frontmatter":{"path":"/boj17612","title":"[C++] BOJ #17612 쇼핑몰"}},"previous":null}},
    "staticQueryHashes": ["3649515864"]}