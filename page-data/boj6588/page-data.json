{
    "componentChunkName": "component---src-templates-prob-solving-template-js",
    "path": "/boj6588",
    "result": {"pageContext":{"html":"<h2>문제</h2>\n<p>1742년, 독일의 아마추어 수학가 크리스티안 골드바흐는 레온하르트 오일러에게 다음과 같은 추측을 제안하는 편지를 보냈다.</p>\n<blockquote>\n<p>4보다 큰 모든 짝수는 두 홀수 소수의 합으로 나타낼 수 있다.</p>\n</blockquote>\n<p>예를 들어 8은 3 + 5로 나타낼 수 있고, 3과 5는 모두 홀수인 소수이다.<br>\n또, 20 = 3 + 17 = 7 + 13, 42 = 5 + 37 = 11 + 31 = 13 + 29 = 19 + 23 이다.</p>\n<p>이 추측은 아직도 해결되지 않은 문제이다.</p>\n<p>백만 이하의 모든 짝수에 대해서, 이 추측을 검증하는 프로그램을 작성하시오.</p>\n<h3>입력</h3>\n<ul>\n<li>입력은 하나 또는 그 이상의 테스트 케이스로 이루어져 있다. 테스트 케이스의 개수는 100,000개를 넘지 않는다.<br>\n각 테스트 케이스는 짝수 정수 n 하나로 이루어져 있다. (6 ≤ n ≤ 1000000)<br>\n입력의 마지막 줄에는 0이 하나 주어진다.</li>\n</ul>\n<h3>출력</h3>\n<ul>\n<li>각 테스트 케이스에 대해서, n = a + b 형태로 출력한다. 이때, a와 b는 홀수 소수이다. 숫자와 연산자는 공백 하나로 구분되어져 있다. 만약, n을 만들 수 있는 방법이 여러 가지라면, b-a가 가장 큰 것을 출력한다. 또, 두 홀수 소수의 합으로 n을 나타낼 수 없는 경우에는 \"Goldbach's conjecture is wrong.\"을 출력한다.</li>\n</ul>\n<hr />\n<h4>1. 해결방법 및 소스코드</h4>\n<p>아리스토테네스의 체를 이용하여 소수를 모두 구해놓은 다음, 구하고자 하는 조합을 출력한다.</p>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\r\n    int N;\r\n    int stop = 0;\r\n\r\n    //oneForPrimes: 소수인 인덱스에는 1을 저장\r\n    //primes: 소수들을 저장할 배열\r\n    //N+1칸을 할당해야 마지막 인덱스가 N\r\n    //일단 모두 소수라고 해놓음.\r\n    vector&lt;bool&gt; oneForPrimes(1000001, true);\r\n    vector&lt;int&gt; primes;\r\n    oneForPrimes[0] = false;\r\n    oneForPrimes[1] = false;\r\n\r\n    //소수만 남기기\r\n    for (int i = 2; i * i &lt;= 1000000; i++)\r\n    {\r\n        if (oneForPrimes[i] == false)\r\n            continue;\r\n\r\n        //true가 저장된 칸이 나오면 그 인덱스의 배수들의 칸을 모두 false로 바꿔준다.\r\n        else\r\n        {\r\n            for (int j = 2; i * j &lt;= 1000000; j++)\r\n            {\r\n                if (oneForPrimes[i * j] == false)\r\n                    continue;\r\n                else\r\n                    oneForPrimes[i * j] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    //남은 소수들을 primes 배열에 저장\r\n    for (int i = 0; i &lt; 1000001; i++)\r\n    {\r\n        if (oneForPrimes[i] == true)\r\n        {\r\n            primes.push_back(i);\r\n        }\r\n    }\r\n\r\n    //판별해 놓은 소수 가지고 합의 조합 구하기\r\n    while (true)\r\n    {\r\n        scanf(&quot;%d&quot;, &amp;N);\r\n        if (N == 0)\r\n            return 0;\r\n\r\n        //소수는 2를 제외하고 모두 홀수\r\n        for (int i = 1; i &lt; primes.size() - 1; i++)\r\n        {\r\n            for (int j = i; j &lt; primes.size(); j++)\r\n            {\r\n                if (primes[i] + primes[j] &gt; N)\r\n                    break;\r\n\r\n                else if (primes[i] + primes[j] == N)\r\n                {\r\n                    printf(&quot;%d = %d + %d\\n&quot;, N, primes[i], primes[j]);\r\n                    stop = 1;\r\n                    break;\r\n                }\r\n                else\r\n                    continue;\r\n            }\r\n\r\n            if (stop)\r\n            {\r\n                stop = 0;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}</code>\n        </deckgo-highlight-code>","title":"[C++] BOJ #6588 골드바흐의 추측","date":"January 28, 2022","next":{"frontmatter":{"path":"/boj1929","title":"[C++] BOJ #1929 소수 구하기"}},"previous":{"frontmatter":{"path":"/boj1016","title":"[C++] BOJ #1016 제곱ㄴㄴ수"}}}},
    "staticQueryHashes": ["3649515864"]}