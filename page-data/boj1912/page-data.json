{
    "componentChunkName": "component---src-templates-prob-solving-template-js",
    "path": "/boj1912",
    "result": {"pageContext":{"html":"<h2>문제</h2>\n<p>n개의 정수로 이루어진 임의의 수열이 주어진다. 우리는 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 한다.</p>\n<p>예를 들어서 10, -4, 3, 1, 5, 6, -35, 12, 21, -1 이라는 수열이 주어졌다고 하자. 여기서 정답은 12+21인 33이 정답이 된다.</p>\n<h3>입력</h3>\n<ul>\n<li>첫째 줄에 정수 n(1 ≤ n ≤ 100,000)이 주어지고 둘째 줄에는 n개의 정수로 이루어진 수열이 주어진다. 수는 -1,000보다 크거나 같고, 1,000보다 작거나 같은 정수이다.</li>\n</ul>\n<h3>출력</h3>\n<ul>\n<li>첫째 줄에 답을 출력한다.</li>\n</ul>\n<hr />\n<h4>1. 나의 해결방법 및 소스코드</h4>\n<ol>\n<li>수를 처음부터 계속 result에 더해나가면서 합을 '최대 힙' 기반의 '우선순위 큐'에 넣어준다.</li>\n<li>계속 더해나가다가 <strong>합이 음수가 되면 그 결과를 우선순위 큐에 넣은 후, result값을 0으로 초기화</strong>시킨다.<br>\n그런 후에 다시 수를 더해나가며 result값을 업데이트 해주고 우선순위 큐에 넣어준다.</li>\n<li>우리가 구하려는 답은 우선순위 큐의 맨 위에 있다.</li>\n<li>2번에서 result값을 0으로 초기화시키고 다시 그 다음부터 합을 더해나가는 이유는, 우리는 연속된 부분합의 최대를 원하는 것인데, 이미 어느부분까지의 부분합이 음수로 전환되었다면,\r\n그 뒤에 나오는 수를 거기에다가 더하는 것보단 result를 그 뒤에 나오는 수부터 다시 더해나가는 편이 당연히 더 크기 때문이다.</li>\n</ol>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int N, x;\r\n    int result = 0;\r\n    vector&lt;int&gt; numbers;\r\n\r\n    scanf(&quot;%d&quot;, &amp;N);\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        scanf(&quot;%d&quot;, &amp;x);\r\n        numbers.push_back(x);\r\n    } //모든 정보 입력 완료\r\n\r\n    priority_queue&lt;int&gt; maxsum;\r\n\r\n    for (int i = 0; i &lt; N; i++)\r\n    {\r\n        // printf(&quot;현재 검사하는 수: %d\\n&quot;, numbers[i]);\r\n        result += numbers[i];\r\n\r\n        if (result &lt; 0)\r\n        {\r\n            // printf(&quot;%d를 큐에 넣습니다\\n&quot;, result);\r\n            maxsum.push(result);\r\n            result = 0;\r\n        }\r\n\r\n        else\r\n        {\r\n            // printf(&quot;%d를 큐에 넣습니다\\n&quot;, result);\r\n            maxsum.push(result);\r\n        }\r\n    }\r\n\r\n    printf(&quot;%d\\n&quot;, maxsum.top());\r\n}</code>\n        </deckgo-highlight-code>\n<br />\n<h4>2. Dynamic Programming을 이용한 풀이</h4>\n<p>이 풀이도 나의 풀이와 맥락은 통한다. <strong>전체 합이 음수가 되면 연속합을 다시 시작하는 것</strong>이 핵심 아이디어이다.</p>\n<ul>\n<li>n번째 수에서의 연속합의 최대값을 dp[n]이라고 하자.</li>\n<li>그러면 dp[n]은 다음과 같이 정의될 수 있다.\n<blockquote>\n<p><code>dp[n] = max(dp[n-1] + arr[n], arr[n])</code></p>\n</blockquote>\n</li>\n<li>우리가 구하는 정답을 나타내는 <code>ans</code> 변수는 <code>dp</code>배열이 업데이트 될 때마다 자기자신과 비교하여 더 큰 값이 나타나면 그것으로 업데이트해준다.</li>\n</ul>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt;\r\nusing namespace std;\r\n\r\nint main(){\r\n    int N;\r\n    int ans;\r\n    int arr[100005];\r\n    int dp[100005];\r\n\r\n    scanf(&quot;%d&quot;, &amp;N);\r\n    for(int i=0; i&lt;N; i++)\r\n        scanf(&quot;%d&quot;, &amp;arr[i]);\r\n\r\n    dp[0] = arr[0];\r\n    ans = arr[0];\r\n\r\n    for(int idx = 1; idx &lt; N; idx++){\r\n        dp[idx] = max(dp[idx-1] + arr[idx], arr[idx]);\r\n        if(ans &lt; dp[idx])\r\n            ans = dp[idx];\r\n        }\r\n\r\n    printf(&quot;%d\\n&quot;, ans);\r\n    }</code>\n        </deckgo-highlight-code>","title":"[C++] BOJ #1912 연속합","date":"2022. 02. 26","next":{"frontmatter":{"path":"/boj20292","title":"[C++] BOJ #20292 컨설팅"}},"previous":{"frontmatter":{"path":"/boj2579","title":"[C++] BOJ #2579 계단 오르기"}}}},
    "staticQueryHashes": ["3649515864"]}