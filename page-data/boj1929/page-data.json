{
    "componentChunkName": "component---src-templates-prob-solving-template-js",
    "path": "/boj1929",
    "result": {"pageContext":{"html":"<h2>문제</h2>\n<p>M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.</p>\n<h3>입력</h3>\n<ul>\n<li>첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.</li>\n</ul>\n<h3>출력</h3>\n<ul>\n<li>한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.</li>\n</ul>\n<hr />\n<h4>1. 처음 소스코드 및 실수</h4>\n<ul>\n<li>당연히 '무지성'으로 소수를 구하는 방법 (2부터 N-1까지로 해당 수를 나누는 작업)은 시간초과가 날 것이 분명했기 때문에 다른 방법을 썼다.</li>\n<li>각 인덱스에 해당하는 자연수가 소수이면 1, 아니면 0으로 체킹하는 벡터를 만들었다.</li>\n<li>벡터를 전부 1로(소수로) 초기화시키고, 반복문을 돌면서 소수를 만날 때마다 N까지의 해당 소수의 배수들을 전부 0으로 바꿔주었다.</li>\n<li>자세한 것은 아래 소스코드 참고 / 하지만 시간초과로 틀렸다.</li>\n</ul>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nusing namespace std;\r\n\r\nint MAX = 1000000;\r\n\r\nint main()\r\n{\r\n    int M, N;\r\n    cin &gt;&gt; M &gt;&gt; N;\r\n\r\n    //oneForPrimes: 소수인 인덱스에는 1을 저장\r\n    //N+1칸을 할당해야 마지막 인덱스가 N\r\n    //일단 모두 소수라고 해놓음.\r\n    vector&lt;int&gt; oneForPrimes(MAX + 1, 1);\r\n    oneForPrimes[0] = 0;\r\n    oneForPrimes[1] = 0;\r\n\r\n    //소수만 남기기\r\n    for (int i = 2; i &lt;= N; i++)\r\n    {\r\n        if (oneForPrimes[i] == 0)\r\n            continue;\r\n\r\n        //1이 저장된 칸이 나오면 그 인덱스의 배수들의 칸을 모두 0으로 바꿔준다.\r\n        else\r\n        {\r\n            for (int j = 2; i * j &lt;= N; j++)\r\n            {\r\n                if (oneForPrimes[i * j] == 0)\r\n                    continue;\r\n                else\r\n                    oneForPrimes[i * j] = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    //정답 출력\r\n    for (int i = M; i &lt;= N; i++)\r\n    {\r\n        if (oneForPrimes[i] == 1)\r\n        {\r\n            cout &lt;&lt; i &lt;&lt; endl;\r\n        }\r\n    }\r\n}</code>\n        </deckgo-highlight-code>\n<br />\n<h4>2. 최종 소스코드 및 해결방법</h4>\n<ul>\n<li>\n<p>시간을 조금 더 줄이기 위해 조금 더 향상된 <strong>에라토스테네스의 체</strong> 방식을 사용했다.</p>\n</li>\n<li>\n<p>일단, N까지의 자연수 중, N/2 이상인 자연수들은 1을 제외하고 어떤 자연수를 곱해도 N이 될 수 없기 때문에, (즉, N의 약수가 될 수 없기 때문에),\r\n배열에서 소수체킹하는 것은 N/2 이하의 자연수들까지만 그 배수들을 소수목록에서 지워주면 된다.<br>\n(현재 소스코드에서는 2부터 N까지 다 체킹하고 있음)</p>\n</li>\n<li>\n<p>더 나아가서, N까지의 자연수 중, <strong>N의 제곱근 이하의 자연수들까지만 그들의 배수를 체킹해주면 된다.</strong><br>\n예를 들어, 35까지의 소수들을 확인한다고 하자. 35의 제곱근은 5.xxx 이므로 5까지만 배수체킹을 해주면 되는데 이유는 다음과 같다.</p>\n</li>\n<li>\n<p>6의 배수를 체킹하려면, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span></span>, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>6</mn><mo>∗</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(6*2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span></span>, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>6</mn><mo>∗</mo><mn>3</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(6*3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">3</span><span class=\"mclose\">)</span></span></span></span></span>, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>6</mn><mo>∗</mo><mn>4</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(6*4)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">4</span><span class=\"mclose\">)</span></span></span></span></span>, <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>6</mn><mo>∗</mo><mn>5</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(6*5)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">5</span><span class=\"mclose\">)</span></span></span></span></span> 등등도 체크하기 위한 반복문을 돌아야 하는데, 이는 이미 그 전 반복문에서 체킹한 것들이다.\r\n따라서, <strong>6의 배수를 체킹하려면 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>6</mn><mo>∗</mo><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6*6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span></span> 부터 체킹하는게 훨씬 효율적</strong>인데, <strong>이미 <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>6</mn><mo>∗</mo><mn>6</mn></mrow><annotation encoding=\"application/x-tex\">6*6</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span><span class=\"mbin\">∗</span><span class=\"mspace\" style=\"margin-right:0.2222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.6444em;\"></span><span class=\"mord\">6</span></span></span></span></span> 은 35를 초과하는 수이므로 6 이상의 자연수들의 배수들은 체킹할 필요가 없다</strong>는 것이다.<br>\n이와 같은 이유로, 우리는 N까지의 소수들을 구하고 싶다면, 2부터 N의 제곱근 이하의 자연수들까지만 각각의 배수들을 배열에서 체킹하면 된다는 것이다.</p>\n</li>\n<li>\n<p>또한, C++의 <code>cin</code>, <code>cout</code>을 사용했을 때는 위의 에라토스테네스의 체를 사용해도 <strong>시간 초과</strong>가 떴는데, C의 <code>printf</code>, <code>scanf</code>를 사용하니까 해결됐다..\r\n<strong>시간제한이 있는 문제라면 왠만하면 <code>cin</code>이나 <code>cout</code>은 쓰지 말자ㅠㅠ</strong></p>\n</li>\n</ul>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\r\n    int M, N;\r\n    scanf(&quot;%d %d&quot;, &amp;M, &amp;N);\r\n\r\n    //oneForPrimes: 소수인 인덱스에는 1을 저장\r\n    //N+1칸을 할당해야 마지막 인덱스가 N\r\n    //일단 모두 소수라고 해놓음.\r\n    vector&lt;bool&gt; oneForPrimes(N + 1, true);\r\n    oneForPrimes[0] = false;\r\n    oneForPrimes[1] = false;\r\n\r\n    //소수만 남기기\r\n    for (int i = 2; i * i &lt;= N; i++)\r\n    {\r\n        if (oneForPrimes[i] == false)\r\n            continue;\r\n\r\n        //true가 저장된 칸이 나오면 그 인덱스의 배수들의 칸을 모두 false로 바꿔준다.\r\n        else\r\n        {\r\n            for (int j = 2; i * j &lt;= N; j++)\r\n            {\r\n                if (oneForPrimes[i * j] == false)\r\n                    continue;\r\n                else\r\n                    oneForPrimes[i * j] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    //정답 출력\r\n    for (int i = M; i &lt;= N; i++)\r\n    {\r\n        if (oneForPrimes[i] == true)\r\n        {\r\n            printf(&quot;%d\\n&quot;, i);\r\n        }\r\n    }\r\n}</code>\n        </deckgo-highlight-code>","title":"[C++] BOJ #1929 소수 구하기","date":"January 27, 2022","next":{"frontmatter":{"path":"/boj14888","title":"[C++] BOJ #14888 연산자 끼워넣기"}},"previous":null}},
    "staticQueryHashes": ["3649515864"]}