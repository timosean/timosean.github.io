{
    "componentChunkName": "component---src-templates-prob-solving-template-js",
    "path": "/boj9663",
    "result": {"pageContext":{"html":"<h2>문제</h2>\n<p>N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.</p>\n<p>N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.</p>\n<h3>입력</h3>\n<ul>\n<li>첫째 줄에 N이 주어진다. (1 ≤ N &#x3C; 15)</li>\n</ul>\n<h3>출력</h3>\n<ul>\n<li>첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.</li>\n</ul>\n<hr />\n<h4>해결방법 및 소스코드</h4>\n<ul>\n<li><strong>Brute Force</strong>하게 재귀호출을 이용한 <strong>백트래킹</strong> 방법을 이용하였다.</li>\n<li>이 문제를 처음 C로 풀었었을 때는 체스판을 2차원 배열로 만들어서 복잡하게 해결했었는데, 이번에는 <strong>1차원 배열</strong>만으로 해결했다.</li>\n<li>굳이 복잡하게 2차원 배열을 만들 필요 없이, 1차원 배열의 <strong>인덱스(<code>i</code>)를 행(level)</strong>, <strong>각 원소(<code>chessBoard[i]</code>)를 열</strong>로 생각하면 된다.</li>\n<li><strong>1차원 배열의 인덱스</strong>도 적절하게 활용하면 코드를 쉽고 간단하게 짤 수 있다는 것을 알게 해 준 문제였다.</li>\n</ul>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nint N;\r\n\r\n//checkPosition: 현재 칸에 퀸을 놓을 수 있는지를 판단한다.\r\n//curlevel: 현재 퀸을 놓으려는 행번호\r\n//curcol: 현재 퀸을 놓으려는 열번호\r\nint checkPosition(int chessBoard[], int curlevel, int curcol)\r\n{\r\n\r\n    //현재 놓으려는 칸의 열이 이전 퀸들과 중복이 있다면 놓을 수 없다.\r\n    for (int i = 0; i &lt; curlevel; i++)\r\n    {\r\n        if (chessBoard[i] == curcol)\r\n            return 0;\r\n    }\r\n\r\n    //현재 놓으려는 칸의 이전 퀸들의 대각위치에 있다면 놓을 수 없다.\r\n    //이전칸 (i, chessBoard[i])과 현재 놓으려는 칸 (curlevel, curcol)에서 x좌표의 차와 y좌표의 차가 같으면 대각위치이다.\r\n    //즉, 두 점을 이은 직선의 기울기의 절대값이 1이면 놓을 수 없다.\r\n    for (int i = 0; i &lt; curlevel; i++)\r\n    {\r\n        if (abs(curlevel - i) == abs(curcol - chessBoard[i]))\r\n            return 0;\r\n    }\r\n\r\n    return 1;\r\n}\r\n\r\nvoid placeQueen(int chessBoard[], int level, int &amp;count)\r\n{\r\n    //탈출 조건(count 증가 조건)\r\n    if (level == N)\r\n        count++;\r\n\r\n    //chessBoard[현재레벨][x]에 퀸을 놓을 수 있는지 검사\r\n    for (int x = 0; x &lt; N; x++)\r\n    {\r\n\r\n        //만약 퀸을 놓을 수 있다면, 퀸을 놓고 다음 단계로 이동.\r\n        if (checkPosition(chessBoard, level, x))\r\n        {\r\n            chessBoard[level] = x;\r\n            placeQueen(chessBoard, level + 1, count);\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    cin &gt;&gt; N;\r\n\r\n    //level: 체스판의 재귀 깊이\r\n    //count: 구하는 경우의 수를 카운트\r\n    int level = 0;\r\n    int count = 0;\r\n\r\n    //체스판 배열에서 각 인덱스는 &#39;행&#39;, 각 원소는 &#39;열&#39;을 의미한다.\r\n    int chessBoard[N];\r\n\r\n    placeQueen(chessBoard, level, count);\r\n\r\n    cout &lt;&lt; count;\r\n}</code>\n        </deckgo-highlight-code>","title":"[C++] BOJ #9663 N-Queen","date":"January 26, 2022","next":{"frontmatter":{"path":"/boj2231","title":"[C++] BOJ #2231 분해합"}},"previous":{"frontmatter":{"path":"/boj14888","title":"[C++] BOJ #14888 연산자 끼워넣기"}}}},
    "staticQueryHashes": ["3649515864"]}