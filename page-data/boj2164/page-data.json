{
    "componentChunkName": "component---src-templates-prob-solving-template-js",
    "path": "/boj2164",
    "result": {"pageContext":{"html":"<h2>문제</h2>\n<p>N장의 카드가 있다. 각각의 카드는 차례로 1부터 N까지의 번호가 붙어 있으며, 1번 카드가 제일 위에, N번 카드가 제일 아래인 상태로 순서대로 카드가 놓여 있다.</p>\n<p>이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다. 우선, 제일 위에 있는 카드를 바닥에 버린다. 그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.</p>\n<p>예를 들어 N=4인 경우를 생각해 보자. 카드는 제일 위에서부터 1234 의 순서로 놓여있다. 1을 버리면 234가 남는다. 여기서 2를 제일 아래로 옮기면 342가 된다. 3을 버리면 42가 되고, 4를 밑으로 옮기면 24가 된다. 마지막으로 2를 버리고 나면, 남는 카드는 4가 된다.</p>\n<p>N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.</p>\n<h3>입력</h3>\n<ul>\n<li>첫째 줄에 정수 N(1 ≤ N ≤ 500,000)이 주어진다.</li>\n</ul>\n<h3>출력</h3>\n<ul>\n<li>첫째 줄에 남게 되는 카드의 번호를 출력한다.</li>\n</ul>\n<hr />\n<h4>1. 기본 아이디어 및 소스코드</h4>\n<ul>\n<li>큐를 활용하여 해결한다.</li>\n<li>문제가 시키는대로만 하면 된다.</li>\n</ul>\n<deckgo-highlight-code language=\"cpp\" terminal=\"carbon\" theme=\"one-dark\"  >\n          <code slot=\"code\">#include &lt;iostream&gt;\r\n#include &lt;queue&gt;\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    int N;\r\n    queue&lt;int&gt; q;\r\n\r\n    scanf(&quot;%d&quot;, &amp;N);\r\n\r\n    //카드 더미 초기화 (바닥부터 맨 위까지 순서대로 N ~ 1까지 저장)\r\n    for (int i = 1; i &lt;= N; i++)\r\n    {\r\n        q.push(i);\r\n    }\r\n\r\n    //카드 더미에 남은 카드가 한 장이 될 때까지 과정을 반복\r\n    while (q.size() != 1)\r\n    {\r\n        q.pop();\r\n        q.push(q.front());\r\n        q.pop();\r\n    }\r\n\r\n    printf(&quot;%d\\n&quot;, q.front());\r\n}</code>\n        </deckgo-highlight-code>","title":"[C++] BOJ #2164 카드2","date":"2022. 02. 08","next":{"frontmatter":{"path":"/boj1158","title":"[C++] BOJ #1158 요세푸스 문제"}},"previous":{"frontmatter":{"path":"/boj1754","title":"[C++] BOJ #1725 히스토그램"}}}},
    "staticQueryHashes": ["3649515864"]}